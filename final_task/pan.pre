# 0 "task.pml"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "task.pml"
# 10 "task.pml"
chan SN_LIGHT_CHANNEL = [1] of {byte};
chan EW_LIGHT_CHANNEL = [1] of {byte};
chan SW_LIGHT_CHANNEL = [1] of {byte};
chan ES_LIGHT_CHANNEL = [1] of {byte};
chan WE_LIGHT_CHANNEL = [1] of {byte};
chan PED_LIGHT_CHANNEL = [1] of {byte};

byte n = 10;

byte currentTurn = 1;
byte queue [6] = {0,0,0,0,0,0};
short requests [7] = {0,0,0,0,0,0};
bool statuses [6] = {false, false, false, false, false, false};


proctype TrafficLight (byte curr_road_id; byte next_road_id; byte competitor_1; byte competitor_2; byte competitor_3; byte competitor_4; chan traffic_channel){
    short curr_road_value = 0;
    short competitor_1_value = 0;
    short competitor_2_value = 0;
    short competitor_3_value = 0;
    short competitor_4_value = 0;
    byte temp = 0;
    do
        :: currentTurn == curr_road_id ->
        if

        :: traffic_channel?temp->
                requests[0] = 0;
                queue[curr_road_id-1] = temp;

                atomic {
                    printf("\n\n\nProcess for road id: %d", curr_road_id);
                    printf("\nN of requests: %d", requests[curr_road_id]);
                    printf("\nCar sensor state: %d", queue[curr_road_id-1]);
                    printf("\nTraffic Light opened: %d", statuses[curr_road_id-1]);
                }

                if
                    :: statuses[curr_road_id-1] == true ->
                        requests[curr_road_id] = 0;
                        statuses[curr_road_id-1] = false;
                        printf ("\n\n\nClose traffic light for road_id: %d", curr_road_id);
                        printf("\nN requests for this road_id: %d", requests[curr_road_id]);
                    :: else -> skip;
                fi;

                if
                :: requests[curr_road_id] > 0 ->
                        printf("\n\n\nAvailable requests for road_id: %d", curr_road_id)
                        if
                        :: (requests[competitor_1] == 0) &&
                            (requests[competitor_2] == 0) &&
                            (requests[competitor_3] == 0) &&
                            (requests[competitor_4] == 0)
                            ->
                                printf("\n\n\nOpen traffic light for road_id: %d", curr_road_id);
                                statuses[curr_road_id-1] = true;
                                queue[curr_road_id-1] = 0;
                                currentTurn = next_road_id
                        :: else ->
                                printf("\n\n\nFailed to open traffic light for road_id: %d", curr_road_id);
                                if
                                    :: requests[competitor_1] > 0 -> competitor_1_value = requests[competitor_1];
                                    :: else -> competitor_1_value = 0;
                                fi;
                                if
                                    :: requests[competitor_2] >0 -> competitor_2_value = requests[competitor_2];
                                    :: else -> competitor_2_value = 0;
                                fi;
                                if
                                    :: requests[competitor_3] >0 -> competitor_3_value = requests[competitor_3];
                                    :: else -> competitor_3_value = 0;
                                fi
                                if
                                    :: requests[competitor_4] >0 -> competitor_4_value = requests[competitor_4];
                                    :: else -> competitor_4_value = 0;
                                fi

                                curr_road_value = requests[curr_road_id];

                                atomic {
                                    printf("\n\n\n --- N requests status (BEFORE CHECK) --- ")

                                    printf("\n\nN requests for curr road_id %d: %d \nN requests for competitor_1 road_id %d: %d \nN requests for competitor_2 road_id %d: %d \nN requests for competitor_3 road_id %d: %d \nN requests for competitor_4 road_id %d: %d", curr_road_id, curr_road_value, competitor_1, competitor_1_value, competitor_2, competitor_2_value, competitor_3, competitor_3_value, competitor_4, competitor_4_value);
                                }

                                if
                                    :: competitor_1_value > curr_road_value || competitor_2_value > curr_road_value || competitor_3_value > curr_road_value ->
                                        requests[curr_road_id] = curr_road_value + n;
                                        requests[competitor_1] = competitor_1_value + n;
                                        requests[competitor_2] = competitor_2_value + n;
                                        requests[competitor_3] = competitor_3_value + n;
                                        requests[competitor_4] = competitor_4_value + n;

                                        printf("\n\n\n --- N requests status (AFTER CHECK, FAILED TO OPEN TRAFFIC LIGHT) --- ")
                                        printf("\n\nN requests for curr road_id %d: %d \nN requests for competitor_1 road_id %d: %d \nN requests for competitor_2 road_id %d: %d \nN requests for competitor_3 road_id %d: %d \nN requests for competitor_4 road_id %d: %d", curr_road_id, requests[curr_road_id], competitor_1, requests[competitor_1], competitor_2, requests[competitor_2], competitor_3, requests[competitor_3], competitor_4, requests[competitor_4]);
                                        skip
                                    :: else ->
                                        printf("\n\n\n --- N requests status (AFTER CHECK, SUCCEEDED TO OPEN TRAFFIC LIGHT) --- ")
                                        printf("\n\nN requests for curr road_id %d: %d \nN requests for competitor_1 road_id %d: %d \nN requests for competitor_2 road_id %d: %d \nN requests for competitor_3 road_id %d: %d \nN requests for competitor_4 road_id %d: %d", curr_road_id, requests[curr_road_id], competitor_1, requests[competitor_1], competitor_2, requests[competitor_2], competitor_3, requests[competitor_3], competitor_4, requests[competitor_4]);
                                        statuses[curr_road_id-1] = true;
                                        queue[curr_road_id-1] = 0;
                                        requests[curr_road_id] = 999 + curr_road_id
                                fi;

                        currentTurn = next_road_id;
                        requests[0] = 0;
                        atomic{
                            printf("\n\n\n --- Global status --- ")
                            printf("\n\nN requests for road_id 1: %d \nN requests for road_id 2: %d \nN requests for road_id 3: %d \nN requests for road_id 4: %d \nN requests for road_id 5: %d \nN requests for road_id 6: %d", requests[1],requests[2],requests[3],requests[4],requests[5],requests[6]);
                            printf("\n\nStatus for road_id 1: %d \nStatus for road_id 2: %d \nStatus for road_id 3: %d \nStatus for road_id 4: %d \nStatus for road_id 5: %d \nStatus for road_id 6: %d", statuses[0],statuses[1],statuses[2],statuses[3],statuses[4],statuses[5]);
                            printf("\n\nCar sensor state for road_id 1: %d \nCar sensor state for road_id 2: %d \nCar sensor state for road_id 3: %d \nCar sensor state for road_id 4: %d \nCar sensor state for road_id 5: %d \nCar sensor state for road_id 6: %d", queue[0],queue[1],queue[2],queue[3],queue[4],queue[5]);
                        }
                        fi
                :: else ->
                        printf("\n\n\nNo requests for road_id: %d", curr_road_id)
                        requests[curr_road_id] = curr_road_id;
                        currentTurn = next_road_id;
                fi;
            fi;
    od
}

proctype CarTrafficGenerator(){
    do
        :: SN_LIGHT_CHANNEL!1
        :: EW_LIGHT_CHANNEL!1
        :: SW_LIGHT_CHANNEL!1
        :: ES_LIGHT_CHANNEL!1
        :: WE_LIGHT_CHANNEL!1
    od
}

proctype PedTrafficGenerator(){
    do
        :: PED_LIGHT_CHANNEL!1
    od
}


init {
    run TrafficLight(1, 2, 2, 4, 5, 0, SN_LIGHT_CHANNEL);
    run TrafficLight(2, 3, 6, 1, 0, 0, EW_LIGHT_CHANNEL);
    run TrafficLight(3, 4, 4, 5, 0, 0, SW_LIGHT_CHANNEL);
    run TrafficLight(4, 5, 6, 1, 3, 5, ES_LIGHT_CHANNEL);
    run TrafficLight(5, 6, 4, 3, 1, 6, WE_LIGHT_CHANNEL);
    run TrafficLight(6, 1, 2, 4, 5, 0, PED_LIGHT_CHANNEL);

    run CarTrafficGenerator();
    run PedTrafficGenerator();
}


ltl s1 { [] ! (statuses[1 -1] && (statuses[2 -1] || statuses[4 -1] || statuses[5 -1])) }
ltl s2 { [] ! (statuses[2 -1] && (statuses[6 -1] || statuses[1 -1])) }
ltl s3 { [] ! (statuses[3 -1] && (statuses[4 -1] || statuses[5 -1])) }
ltl s4 { [] ! (statuses[4 -1] && (statuses[6 -1] || statuses[1 -1] || statuses[3 -1] || statuses[5 -1])) }
ltl s5 { [] ! (statuses[5 -1] && (statuses[4 -1] || statuses[3 -1] || statuses[1 -1] || statuses[6 -1])) }
ltl s6 { [] ! (statuses[6 -1] && (statuses[2 -1] || statuses[4 -1] || statuses[5 -1])) }


ltl l1 { []( (queue[1 -1] == 1 && statuses[1 -1]==false) -> <> (statuses[1 -1]==true) ) }
ltl l2 { []( (queue[2 -1] == 1 && statuses[2 -1]==false) -> <> (statuses[2 -1]==true) ) }
ltl l3 { []( (queue[3 -1] == 1 && statuses[3 -1]==false) -> <> (statuses[3 -1]==true) ) }
ltl l4 { []( (queue[4 -1] == 1 && statuses[4 -1]==false) -> <> (statuses[4 -1]==true) ) }
ltl l5 { []( (queue[5 -1] == 1 && statuses[5 -1]==false) -> <> (statuses[5 -1]==true) ) }
ltl l6 { []( (queue[6 -1] == 1 && statuses[6 -1]==false) -> <> (statuses[6 -1]==true) ) }


ltl f1 { []( <> (statuses[1 -1] == false) ) }
ltl f2 { []( <> (statuses[2 -1] == false) ) }
ltl f3 { []( <> (statuses[3 -1] == false) ) }
ltl f4 { []( <> (statuses[4 -1] == false) ) }
ltl f5 { []( <> (statuses[5 -1] == false) ) }
ltl f6 { []( <> (statuses[6 -1] == false) ) }
